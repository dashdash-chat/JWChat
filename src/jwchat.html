<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title><l>JWChat</l></title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <script src="config.js" language="JavaScript1.2"></script>
    <script src="shared.js" language="JavaScript1.2"></script>
    <script src="browsercheck.js" language="JavaScript1.2"></script>
    <script src="sounds.js" language="JavaScript1.2"></script>
    <script src="statusLed.js" language="JavaScript1.2"></script>
    <script src="roster.js" language="JavaScript1.2"></script>
    <script language="JavaScript1.2">
<!--

 /*
  * JWChat, a web based jabber client
  * Copyright (C) 2003-2004 Stefan Strigler <steve@zeank.in-berlin.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  *
  * Please visit http://jwchat.sourceforge.net for more information!
  */

/* vars representing some internal status information */
var jid;
var pass;	
var nick;
var vcard;
var status = '';
var sid = 0;
var onlstat = '';
var onlmsg = '';
var autoPopup = true;
var autoPopupAway = false;
var playSounds = false;
var focusWindows = true;
var timestamps = true;
var usersHidden = false;
var enableLog = false;
var loghost;

/* some globals */
var roster;
var timeout_tag;

var fmd; // shortcut to main frame
var fhd; // shortcut to hidden frame
/* var statusbox;*/  // shortcut to status select box
var statusLed;
var statusMsg;

var onlstatus = new Object();
onlstatus["available"] = loc("online");
onlstatus["chat"] = loc("free for chat");
onlstatus["away"] = loc("away");
onlstatus["xa"] = loc("not available");
onlstatus["dnd"] = loc("do not disturb");
onlstatus["invisible"] = loc("invisible");
onlstatus["unavailable"] = loc("invisible");

// the debugger
var debugW;
var debugMsgs = new Array(); 

function fdebug(str,lv) {
  if (!DEBUG || (USE_DEBUGJID && cutResource(jid) != DEBUGJID)) // what the hell are we doing here
    return;

  var msg = new Object();
  msg.str = str;
  msg.lv = lv;
  if (fdebug.caller)
    msg.caller = fdebug.caller.name;
  else
    msg.caller = 'undefined';

  debugMsgs = debugMsgs.concat(msg);

  if (!debugW || debugW.closed) // open the debugger
    debugW = window.open("debug.html",makeWindowName(jid)+"debugW","width=480,height=320,scrollbars=yes,resizable=yes");

  if (!debugW || !debugW.popMsgs)
    return;
  debugW.popMsgs();
}

var messageHistory = new Array();
var historyIndex = 0;
function getHistory(key, message) {
  if ((key == "up") && (historyIndex > 0)) historyIndex--;
  if ((key == "down") && (historyIndex < messageHistory.length)) historyIndex++;
  if (historyIndex >= messageHistory.length) {
    if (historyIndex == messageHistory.length) return '';
    return message;
  } else {
    return messageHistory[historyIndex];
  }
}

function addtoHistory(message) {
  if (is.ie5)
    messageHistory = messageHistory.concat(message);
  else
    messageHistory.push(message);
  historyIndex = messageHistory.length;
}

function openGroupchat(jid,nick,pass) {
	pass = pass || '';

  var user = roster.getUserByJID(jid);
  if(!user) {
    user = roster.addUser(new RosterUser(jid,'',[loc('Chat Rooms')],jid.substring(0,jid.indexOf('@'))));
		user.type = 'groupchat';
    roster.print();
  }
	if (!user.chatW || user.chatW.closed)
		user.chatW = open("groupchat.html?jid="+escape(jid)+"&nick="+escape(nick)+"&pass="+escape(pass),"gchatW"+makeWindowName(jid+"/"+nick),"width=390,height=520,resizable=yes");
	user.chatW.focus();
}

var subw;
function openSubscription(jid) {
  var param = (jid) ? "?jid="+escape(jid) : "";
  subw = open("subscription.html"+param,"sub","width=320,height=240,resizable=yes");
	subw.focus();
  return false;
}

function openCustomPresence(jid) {
	var user = roster.getUserByJID(jid);
	if (!user)
		return;
  if (!user.onlStatW || user.onlStatW.closed)
    user.onlStatW = open("changestatus.html?jid="+jid,"onlStatW","width=330,height=240,resizable=yes");
  user.onlStatW.focus();
  return false;
}

function sendCustomPresence(jid,presence,msg) {
	var param = "?sid="+sid+"&to="+jid;

	switch (presence) {
	case 'offline':
		param += "&type=unavailable";
	case 'unavailable':
		param += "&type=unavailable";
		presence = "invisible";
	default:
		param += "&show="+presence;
	}

	if (typeof(msg) != 'undfined' && msg != '')
		param += "&status="+msg;

	fhdLoad("presence",param);
}

function openUserProps(jid) {
  open("userprops.html?jid="+escape(jid),"uProps"+makeWindowName(jid),"width=480,height=360,resizable=yes");
  return false;
}

function removeUser(jid) {
	// get fulljid
	var fulljid = roster.getUserByJID(jid).fulljid;
  fhdLoad("roster","?sid="+sid+"&jid="+fulljid+"&subscription=remove");
}

function openUserInfo(jid) {
	// query vcard-temp
	fCBLoad("vcard","?sid="+sid+"&to="+jid,handleVCardTemp);
	return false;
}

function openUserHistory(jid) {

	if (typeof(loghost) == 'undefined')
		return;

	var user = roster.getUserByJID(jid);

	if (user == null)
		return;

	if (!user.histW || user.histW.closed)
		user.histW = open("userhist.html?jid="+escape(jid),"histW"+makeWindowName(jid),"width=600,height=400,resizable=yes,scrollbars=no");
	user.histW.focus();
}

var searchW;
function openSearch() {
	if (!searchW || searchW.closed)
		searchW = open("search.html","searchW"+makeWindowName(jid),"width=480,height=260,resizable=yes,scrollbars=yes");
	searchW.focus();
	return false;
}

var ebW
function openEditBookmarks() {
	if (!ebW || ebW.closed)
		ebW = open("editbookmarks.html","ebw"+makeWindowName(jid),"width=330,height=290,resizable=yes");
	return false;
}

function playSound(action) {
  if (!playSounds)
    return;
  if(!SOUNDS[action]) {
    fdebug("no sound for '" + action + "'",2);
    return;
  }

	if (onlstat != 'available' || onlstat == 'chat')
		return;
	
  var frameD = frames["jwc_sound"].document;
  var html = "<embed src=\""+SOUNDS[action]+"\" width=\"1\" height=\"1\" quality=\"high\" pluginspage=\"http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash\" type=\"application/x-shockwave-flash\">";
  frameD.open();
  frameD.write(html);
  frameD.close();
}


/* load frame and store callback */
var registeredCBs = new Array();
function fCBLoad(func,param,callback,args) {

	// register callback with handler (this is a oneshot handler!)
	var cbObj = new Object();
	cbObj.func = callback;
	cbObj.args = args || null;
	registeredCBs[registeredCBs.length] = cbObj;

	fdebug("registeredCBs: " + registeredCBs,4);

  if (is.ie5 || is.op)
    frameLoad(frames["jwc_cb"],func,param,"parent.handleCB();");
  else
    frameLoad(frames["jwc_cb"],func,param);
}

function fhdLoad(func,param) {
  if (is.ie5 || is.op)
    frameLoad(frames["jwc_out"],func,param,"parent.run();");
  else
    frameLoad(frames["jwc_out"],func,param);
}

function frameLoad(frame,func,param,onload) {
  var ext = ".jsx"; // protocol extension for wcs
  var ext2 = ".js";
  var url = sWCS + func + ext + param;
  var url2 = sWCS2 + func + ext2 + param;
  /* doesn't work with mozilla */
  if (is.ie || is.op) {
    fdebug("frameLoad:\n" + url2,4);
    frame.document.open();
    if (onload)
      frame.document.write("<script src=\""+url2+"\"></script><script>function checkData() { if (typeof(jabber)=='undefined') setTimeout(\"checkData()\",100); else " + onload + " } onload = checkData;</script>");
    else 
      frame.document.write("<script src=\""+url2+"\"></script>");
    frame.document.close();
  } else {
    fdebug("frameLoad:\n" + url,4);
    
    frame.location.href = url;
  }
}

function isGateway(aJid) {
	aJid = cutResource(aJid);
	for (var i in disco.items)
		if (aJid == disco.items[i].jid)
			if (typeof(disco.items[i].info) != 'undefined') {
				for (var j in disco.items[i].info)
					if (disco.items[i].info[j].tagname == 'identity' && disco.items[i].info[j].category == 'gateway') {
						return true;
					}
available			}
	return false;
}

function setPollInterval(val) {
  if (timeout_tag)
    clearTimeout(timeout_tag);
  timerval = val;
  poll();
}

/************************************************************************
 *                   ***** EVENT - HANDLER *****
 ************************************************************************
 */

var rh = new Object(); // registered handlers
function registerHandler(type,func) {
  if (!rh[type])
    rh[type] = new Array(func);
  else 
    rh[type] = rh[type].concat(func);
}
	
function handleEvent() {
  
  if (status != 'polling')
    return;

  var jabber = frames["jwc_in"].jabber;

  /* error handling */
  if (!jabber) { // connection lost
    if (typeof(pass) == 'undefined') { // no pw - we can't reconnect
      alert(loc("An error occured!\nAborting..."));
      window.close();
      return;
    }

    if (confirm(loc("Connection lost!\nReconnect?"))) {
      cleanUp();
      changeStatus(onlstat);
    } else {
      logout();
    }
    return;
  }
  
	fdebug(jabber,4);
  
  if (jabber && jabber.error && sid != 0) {
		fdebug("From: " + jabber.from + "\n" + jabber.error,1);
    if (!jabber.type || jabber.type != "error") {
      alert(loc("An error occured!\nAborting..."));
      if (typeof(pass) == 'undefined')
        window.close();
      else
        logout();
      return;
    }
  }
  /* END error handling */		

  if (!jabber.name) { // no event to handle
    clearTimeout(timeout_tag);
    timeout_tag = setTimeout("poll()",timerval);
    return; // don't trigger again
  }
  

  if (rh[jabber.name]) {
    for (var i in rh[jabber.name])
      rh[jabber.name][i](jabber);
  } else {
    fdebug("handleEvent: unregistered type: " + jabber.name,1);
  }
  
  poll(); // trigger new poll
}

/************************************************************************
 * handleMessage
 ************************************************************************
 */

function storeCID(jabber,jid) {
	fdebug(jabber,0);
	var user = roster.getUserByJID(jid);
	if (user == null) {
		fdebug("user with jid " + jid + " not found",1);
		return;
	}

	if (user.chatW && !user.chatW.closed) // store cid
		user.chatW.cid = jabber.cid;
}

function handleMessage(jabber) {

	fdebug(jabber,2);

	if (jabber.type == 'error')
		return;

	/* check if this is a groupchat invite */
	if (jabber.o) {
		for (var i in jabber.o) {
			if (jabber.o[i].tagname == 'x' && jabber.o[i].xmlns == 'http://jabber.org/protocol/muc#user' && jabber.o[i].o) {
				var from, to, reason, pass;
				for (var j in jabber.o[i].o) { // collect data
					if (jabber.o[i].o[j].tagname == 'invite') {
						from = jabber.o[i].o[j].from;
						to = jabber.from;
						if (jabber.o[i].o[j].password)
							pass = jabber.o[i].o[j].password;
						if (jabber.o[i].o[j].reason)
							reason = jabber.o[i].o[j].reason;
					}
				}
				fdebug("You have been invited to " + jid + " pass " + pass + " by " + from + "\nreason:" + reason,2);
				var user = roster.getUserByJID(from);
				if (user == null) {// users not in roster (yet)
					fdebug("creating new user "+from,3);
					user = roster.addUser(new RosterUser(from));
					user.lastsrc = eval(user.status + "Led").src;
					roster.print();
				}

				if (typeof(user.iwArr) == 'undefined')
					user.iwArr = new Array();

				user.iwArr[to] = open("groupchat_invite.html?to="+to+"&from="+from+"&pass="+pass+"&reason="+reason,"iw"+makeWindowName(to),"width=320,height=320,resizable=yes");

				return;
			}
		}
	}

  var from = cutResource(jabber.from);
  
  fdebug("from: "+from+", jabber.from: "+jabber.from,3);

  var user = roster.getUserByJID(from);
  if (user == null) {// users not in roster (yet)
    fdebug("creating new user "+from,3);
    user = roster.addUser(new RosterUser(from));
    user.lastsrc = eval(user.status + "Led").src;
    roster.print();
  }

  fdebug("got user jid: "+user.jid,3);

  var aRoster = roster;
  if (jabber.type != 'groupchat' && user.roster && from != jabber.from) { // private groupchat message
    aRoster = user.roster;
    from = jabber.from; // we cut the resource - now 
    user = user.roster.getUserByJID(from);
  }

  /* change icon in roster - but not if it's a groupchat item */
  if (jabber.type != 'groupchat') {
    if (!user.lastsrc)
      user.lastsrc = eval(user.status + "Led").src;
      
    var images = aRoster.getUserIcons(from);
    for (var i=0; i<images.length; i++)
      images[i].src = messageImg.src;

    /* user is not visible right now - make him pop up (lastsrc changed!) */
    if (aRoster.usersHidden && user.status == 'unavailable')
      aRoster.print();
  }

	// set current timestamp
	jabber.timestamp = new Date();

  if (jabber.type == 'chat' && !(jabber.o && jabber.o[0] && typeof(jabber.o[0].stamp) != 'undefined')) {
    
      /* we got a real chat message (and not an offline message)
       */

    user.chatmsgs = user.chatmsgs.concat(jabber);
    
    if (user.chatW && !user.chatW.closed && user.chatW.popMsgs) {
      user.chatW.popMsgs();
      playSound('chat_recv');
    } else if (autoPopup && (autoPopupAway || onlstat == "available" || onlstat == "chat")) {
      aRoster.openChat(from);
      playSound('chat_recv');
    } else {
      if (focusWindows) window.focus();
      playSound('chat_queue');

			// let arrow blink for toggled groups
			for (var i in user.groups) {
				if (user.groups[i] != '') {
					//fmd.getElementById(user.groups[i]+"Head").style.color = "red";
					if (roster.hiddenGroups[user.groups[i]])
						fmd.images[user.groups[i]+"Img"].src = arrow_right_blinking.src;
				}					
			}
    }

		// send back to server
    if (user.chatW && !user.chatW.closed && typeof(user.chatW.cid)!='undefined') {
			if (enableLog && typeof(loghost) != 'undefined')
				fhdLoad("archive-set","?sid="+sid+"&to="+loghost+"&msg_from="+msgEscape(jabber.from)+"&msg_body="+msgEscape(jabber.body)+"&cid="+msgEscape(user.chatW.cid));
		} else {
			if (enableLog && typeof(loghost) != 'undefined')
				fCBLoad("archive-set","?sid="+sid+"&to="+loghost+"&msg_from="+msgEscape(jabber.from)+"&msg_body="+msgEscape(jabber.body),storeCID,user.jid);
		}

  } else if (jabber.type == 'groupchat') {

      /* handle groupchat message 
       */

    user.chatmsgs = user.chatmsgs.concat(jabber);
    if (user.chatW && !user.chatW.closed && user.chatW.srcW && typeof(user.chatW.srcW.roster) != 'undefined' && user.chatW.popMsgs) {
      user.chatW.popMsgs();
    } 

    playSound('chat_recv');
    
  } else {

      /* must have been an offline message - handle as normal message as
       * opening a chat window doesn't make sense most probably 
       */

    user.messages = user.messages.concat(jabber);
    if (autoPopup && (autoPopupAway || onlstat == "available" || onlstat == "chat") && (!user.mW || user.mW.closed)) {
      aRoster.openMessage(from);
      playSound('message_recv');
    } else if (user.mW && !user.mW.closed && user.messages.length > 0 && user.mW.document.forms[0]) {
      user.mW.document.forms[0].nextButton.disabled = false;
      if (focusWindows) user.mW.focus();
      playSound('message_recv');
    }	else {
      if (focusWindows) window.focus();
      playSound('message_queue');
			// let arrow blink for toggled groups
			for (var i in user.groups) {
				if (user.groups[i] != '') {
					//fmd.getElementById(user.groups[i]+"Head").style.color = "red";
					if (roster.hiddenGroups[user.groups[i]])
						fmd.images[user.groups[i]+"Img"].src = arrow_right_blinking.src;
				}					
			}

    }

		// store message
		if (enableLog && typeof(loghost) != 'undefined')
			fhdLoad("archive-set","?sid="+sid+"&to="+loghost+"&msg_from="+msgEscape(jabber.from)+"&msg_body="+msgEscape(jabber.body));
  }

}

/************************************************************************
 * handleMessageError
 ************************************************************************
 */
var error_messages = new Array();
var errorW;
function handleMessageError(jabber) {

	if (jabber.type != 'error')
		return;

	fdebug(jabber,1);

	error_messages = error_messages.concat(jabber);

	if (!errorW || errorW.closed)
		errorW = open("error_message.html","errorW"+makeWindowName(jid),"width=360,height=270,dependent=yes,resizable=yes");
	else if (error_messages.length > 0 && errorW.document.forms[0])
		errorW.document.forms[0].nextButton.disabled = false;

	playSound('error');

	errorW.focus();
}

/************************************************************************
 * handlePresence
 ************************************************************************
 */

function handlePresence(jabber) {
  var from = cutResource(jabber.from);
  var aRoster = roster;

  if (from == cutResource(jid)) // skip my own presence msgs
    return;

  if (!is.ie)
    fdebug(jabber,2);

  if (jabber.type) {
    if (jabber.type == 'subscribe') {
			if (isGateway(from)) { // automatically subscribe to gateways
				fhdLoad("presence","?sid="+sid+"&to="+jabber.from+"&type=subscribed");
			}
			else
				window.open("subscriptionRequest.html?jid="+escape(from)+"&msg="+escape(jabber.status),"sr"+makeWindowName(from),"width=320,height=240");

      return;
    }
    if (jabber.type == 'unsubscribe')
      alert(loc("You have been unsubscribed from [_1]", jabber.from));

		if (jabber.type == 'error' && typeof(jabber.o) != 'undefined') {
// 			for (var i in jabber.o) {
// 				if (jabber.o[i].tagname == 'error' && jabber.o[i].data != '')
// 					alert("From: "+from+"\nError (Code:"+jabber.o[i].code+")\n\n"+jabber.o[i].data);
// 			}
			return;
		}
  }

  var user = roster.getUserByJID(from);
  if (!user) // presence from unsubscribed user
    return;

	/* handle presence for groupchat roster */
  if (jabber.o && user.roster) { // seems to be a special presence (assumed to be for MUC)
    fdebug("opresence: " + jabber.o,3);
    
    var ofrom = jabber.from.substring(jabber.from.indexOf('/')+1);

    fdebug("jabber.from:"+jabber.from+", ofrom:"+ofrom,3);

    var ouser = user.roster.getUserByJID(jabber.from);
    if (!ouser) // no user? create one!
      ouser = new GroupchatRosterUser(jabber.from,ofrom);

    /* grep for extended attributes */
		var nickChanged = false;
    for (var i in jabber.o) {
      if (jabber.o[i].tagname = 'x' && jabber.o[i].o) {
        for (var j in jabber.o[i].o) {
          if (jabber.o[i].o[j].tagname == 'item') {
						var item = jabber.o[i].o[j];
						ouser.affiliation = item.affiliation;
						ouser.role = item.role;
						ouser.nick = item.nick;
						ouser.realjid = item.jid;
						ouser.reason = item.reason;
						if (item.o) {
							for (var k in item.o) {
								if (item.o[k].tagname = 'actor')
									ouser.actor = item.o[k].jid;
							}
						}

            fdebug("ouser.jid: "+ ouser.jid + ", ouser.fulljid:" + ouser.fulljid + ", ouser.name:"+ouser.name+", user.roster.nick:"+user.roster.nick,3);


						if (item.role != '') {
							ouser.add2Group(ouser.role+'s');
            
							/* check if it is our own presence
							 * must be done here cause we want to be sure that role != ''
							 */
            
							if (ouser.name == user.roster.nick) { // seems to be me
								user.roster.me = ouser; // store this reference
								if (user.chatW.updateMe)
									user.chatW.updateMe();
							}
						}
          }
				}
        for (var j in jabber.o[i].o) {
					if (jabber.o[i].o[j].tagname == 'status' && typeof(jabber.o[i].o[j].code) != 'undefined') {
						switch (jabber.o[i].o[j].code) {
						case '201': // room created
							/* popup dialog to ask for whether to accept default
							 * configuration or make a custom room 
							 */
							if (confirm(loc("A new room has been created but it awaits configuration from you. Do you want to do a custom configuration now?\nNote: Click on 'Cancel' to start with a default configuration!")))
								user.chatW.openConfig();
							else
								fhdLoad("iq","?sid="+sid+"&to="+msgEscape(user.jid)+"&ns=http://jabber.org/protocol/muc%23owner&set="+escape("<x xmlns='jabber:x:data' type='submit'/>"));
							break;
						case '303': // nick change
							// display message
							if (!ouser.nick)
								return;

							var aMessage = new Object();
							aMessage.from = user.jid;
							aMessage.body = loc("[_1] is now known as [_2]",ouser.name, ouser.nick);
							user.chatmsgs = user.chatmsgs.concat(aMessage);
							if (user.chatW && !user.chatW.closed && user.chatW.popMsgs)
								user.chatW.popMsgs();			

							// update nick if it's me
							if (ouser.name == user.roster.nick)
								user.roster.nick = ouser.nick;

							// remove old user
							user.roster.removeUser(ouser);

							// add new user
							ouser = new GroupchatRosterUser(jabber.from.substring(0,jabber.from.lastIndexOf('/')+1).concat(ouser.nick),ouser.nick);
							fdebug(ouser,0);
							user.roster.addUser(ouser);
							nickChanged = true;
							break;
						case '301': // user has been kicked
							var aMessage = new Object();
							aMessage.from = user.jid;
							aMessage.body = loc("[_1] has been banned by [_2]: [_3]",ouser.name,ouser.actor,ouser.reason);
							user.chatmsgs = user.chatmsgs.concat(aMessage);
							if (user.chatW && !user.chatW.closed && user.chatW.popMsgs)
								user.chatW.popMsgs();			
							
							playSound('chat_recv');
							break;
						case '307': // user has been kicked
							var aMessage = new Object();
							aMessage.from = user.jid;
							aMessage.body = loc("[_1] has been kicked by [_2]: [_3]",ouser.name,ouser.actor,ouser.reason);
							user.chatmsgs = user.chatmsgs.concat(aMessage);
							if (user.chatW && !user.chatW.closed && user.chatW.popMsgs)
								user.chatW.popMsgs();			
							
							playSound('chat_recv');
							break;
						}
					}
        }
      }
    }

    fdebug("<"+ouser.name+"> affiliation:"+ouser.affiliation+", role:"+ouser.role,3);

    if (!user.roster.getUserByJID(jabber.from) && !nickChanged) {
			// add user
      user.roster.addUser(ouser);

			// show join message
			var aMessage = new Object();
			aMessage.from = user.jid;
			aMessage.body = loc("[_1] has become available",ouser.name);
			user.chatmsgs = user.chatmsgs.concat(aMessage);
			if (user.chatW && !user.chatW.closed && user.chatW.popMsgs)
				user.chatW.popMsgs();			

			playSound('online');

    } else if (jabber.type && jabber.type == 'unavailable' && !nickChanged) {
			// show part message
			var aMessage = new Object();
			aMessage.from = user.jid;
			aMessage.body = loc("[_1] has left",ouser.name);
			if (jabber.status)
				aMessage.body += ": " + jabber.status;
			user.chatmsgs = user.chatmsgs.concat(aMessage);
			if (user.chatW && !user.chatW.closed && user.chatW.popMsgs)
				user.chatW.popMsgs();			

			playSound('offline');

		} else
      user.roster.updateGroups();

    // relink roster and user
    aRoster = user.roster;
    user = ouser;
  } 

  if (jabber.show) {
    if (user.status == 'unavailable')
      playSound('online');
		if (jabber.show == 'online') // quick fix for JIT which sends this presence ...
			jabber.show = 'available';
    user.status = jabber.show;
  } else if (jabber.type) {
    if (jabber.type == 'unsubscribe') {
      user.subscription = 'from';
      user.status = 'stalker';
    } else if (user.status != 'stalker')
      user.status = 'unavailable';
    if (aRoster.name == 'GroupchatRoster' && !nickChanged) { // it's a groupchat roster
			// remove user
      aRoster.removeUser(user); // we don't need offline users in there
		}
    playSound('offline');
  } else {
    if (user.status == 'unavailable') // user was offline before
      playSound('online');
    user.status = 'available';
  }

  var img = eval(user.status+"Led");
  
  if (user.lastsrc) // message is pending
    user.lastsrc = img.src;
  
  // show away message
  if (jabber.status)
    user.statusMsg = jabber.status;
  else
    user.statusMsg = null;
  
	// update presence indicator of chat window
	if (user.chatW && !user.chatW.closed) 
		user.chatW.updateUserPresence();

  aRoster.print(); // update roster
}

/************************************************************************
 * handleIQSet
 ************************************************************************
 */

function handleIQSet(jabber) {
  if (jabber.type != "set")
    return;

  fdebug("got iq type 'set':\n"+jabber,2);
  
  for (var i in jabber.items) {
    var item = jabber.items[i];
    var user = roster.getUserByJID(cutResource(item.jid));
    if (user) {
      user.subscription = item.subscription;
      if (item.subscription == 'remove') {
				fdebug("removing user " + user.jid,2);
        roster.removeUser(user);
      } else { // update user
        item.name = item.name? item.name : item.jid;
        user.name = item.name;
        user.groups = item.groups;
        roster.updateGroups();
      }
    } else {// got a new user
			if (isGateway(item.jid)) { // auto add
				// get name
				item.name = item.jid;
				for (var i in disco.items)
					if (disco.items[i].jid == cutResource(item.jid))
						item.name = disco.items[i].name;

				// add to roster
				var aUser = new RosterUser(cutResource(item.jid),item.subscription,["Gateways"],item.name);
				aUser.fulljid = item.jid;
				roster.addUser(aUser);

				// tell server about it
				fhdLoad("roster","?sid="+sid+"&jid="+item.jid+"&name="+item.name+"&group=Gateways");

				// send subscription
				/*				if (item.subscription == "from")
				 * fhdLoad("presence","?sid="+sid+"&to="+item.jid+"&type=subscribe");*/
			} else {
				if (typeof(item.name) == 'undefined' || item.name == '')
					item.name = item.jid;
				
				roster.addUser(new RosterUser(item.jid,item.subscription,item.groups,item.name));

				var groups = '';
				for (var i in item.groups)
					if (item.groups[i] != '')
						groups += item.groups[i] + ";";
				if (groups != '')
					fhdLoad("roster","?sid="+sid+"&jid="+item.jid+"&name="+item.name+"&group="+groups); // don't set groups
				else
					fhdLoad("roster","?sid="+sid+"&jid="+item.jid+"&name="+item.name); // don't set groups
				//				openUserProps(item.jid);
				if (item.subscription == "from")
					openSubscription(item.jid); // subscribe to user
			}
    }
  }
  roster.print();
}

/************************************************************************
 * handleIQResult
 ************************************************************************
 */
	
function handleIQResult(jabber) {
  if (!jabber) // nothing to do
    return;

  if (jabber.type != 'result' && jabber.type != 'error') // error handling should be done
                                                         // inside specific iq handler
    return;

  fdebug("got iq type 'result':\n"+jabber,2);
}

registerHandler("message",handleMessage);
registerHandler("message",handleMessageError);
registerHandler("presence",handlePresence);
registerHandler("iq",handleIQSet);
registerHandler("iq",handleIQResult);

/************************************************************************
 * handleCB
 * handles the registered Callback from fCBLoad
 ************************************************************************
 */
function handleCB(jabber) {
  jabber = jabber || frames['jwc_cb'].jabber;
	
	if (!jabber) // nothing to do
    return;

  fdebug(jabber,3);

	if (registeredCBs.length == 0) {
		fdebug("no callbacks registered ... aborting!",1);
		return;
	}

	/* loop registered callbacks */

	for (var i=0; i<registeredCBs.length; i++) {
		if (typeof(registeredCBs[i].func) != 'undefined' && registeredCBs[i].func) {
			if (registeredCBs[i].args)
			 	registeredCBs[i].func(jabber,registeredCBs[i].args);
			else
			 	registeredCBs[i].func(jabber);
			 
			}
			else
				fdebug("No callback assigned for this query",1);

		/* remove callback from list */

		registeredCBs = registeredCBs.slice(0,i).concat(registeredCBs.slice(i+1,registeredCBs.length));

	}
}

/************************************************************************
 *                  ***** CALLBACKS from fCBLoad *****
 ************************************************************************
 */

function handleVCardTemp(jabber) {

	if (jabber.error || jabber.type == 'error') {
		fdebug(jabber,1);
		return;
	}

	fdebug(jabber,2);

	if (typeof(jabber.ns) == 'undefined' || jabber.ns != 'vcard-temp') // not form me
		return;

  if (cutResource(jabber.from) == cutResource(jid))
    vcard = jabber.vcard; // save my own vcard
  else {
    var user = roster.getUserByJID(cutResource(jabber.from));
    
    if (user == null)
      user = roster.addUser(new RosterUser(jabber.from));
    
    user.vcard = jabber.vcard;
  }

  open("vcard.html?jid="+escape(jabber.from),"vcardW"+makeWindowName(jabber.from),"width=400,height=500,scrollbars=yes");
}


var bookmarks = new Array();
function handleBookmarks(jabber) {
	if (jabber)
		fdebug(jabber,2);

	if (jabber && (jabber.error || jabber.type == 'error'))
		fdebug(jabber,1);

	if (jabber && !(jabber.error || jabber.type == 'error')) {
	
		for (i in jabber.browse.o) {
			var idx = 0;
			if (jabber.browse.o[i].tagname == 'storage') {
				for (var j in jabber.browse.o[i].o) {
					var bookmark = jabber.browse.o[i].o[j];
					
					if (bookmark.tagname != 'conference')
						continue;
					
					bookmarks[idx++] = bookmark; // store bookmark
					
					// do autojoin
					if (bookmark.autojoin == '1')
						openGroupchat(bookmark.jid,bookmark.nick,bookmark.pass);
				}
			}
		}
	}

	// start service discovery
	fCBLoad("iq","?sid="+sid+"&to="+JABBERSERVER+"&ns=http://jabber.org/protocol/disco%23items",handleDiscoItemResult); 
}

function handlePrefs(jabber) {
	if (jabber)
		fdebug(jabber,2);

	if (jabber && (jabber.error || jabber.type == 'error'))
		fdebug(jabber,1);

	if (jabber && !(jabber.error || jabber.type == 'error')) {
		for (var i in jabber.browse.o) {
			var item = jabber.browse.o[i];
			if (item.tagname == 'jwchat' && item.xmlns == 'jwchat:prefs') {
				if (eval(item.usersHidden))
					roster.toggleHide();
				if (typeof(item.timerval) != 'undefined' && !isNaN(item.timerval))
					timerval = item.timerval;
				if (typeof(item.autoPopup) != 'undefined' && item.autoPopup != 'undefined')
					autoPopup = eval(item.autoPopup);
				if (typeof(item.autoPopupAway) != 'undefined' && item.autoPopupAway != 'undefined')
					autoPopupAway = eval(item.autoPopupAway);
				if (typeof(item.playSounds) != 'undefined' && item.playSounds != 'undefined')
					playSounds = eval(item.playSounds);
				if (typeof(item.focusWindows) != 'undefined' && item.focusWindows != 'undefined')
					focusWindows = eval(item.focusWindows);
				if (typeof(item.timestamps) != 'undefined' && item.timestamps != 'undefined')
					timestamps = eval(item.timestamps);
				if (typeof(item.enableLog) != 'undefined' && item.enableLog != 'undefined')
					enableLog = eval(item.enableLog);
			}
		}
	}

	// get bookmarks
	fCBLoad("iq","?sid="+sid+"&ns=jabber:iq:private&get="+msgEscape("<storage xmlns='storage:bookmarks' />"),handleBookmarks);
}

function handleSavedState(jabber) {
	if (jabber)
		fdebug(jabber,2);

	if (jabber && (jabber.error || jabber.type == 'error'))
		fdebug(jabber,1);

	if (jabber && !(jabber.error || jabber.type == 'error')) {
		for (var i in jabber.browse.o) {
			var item = jabber.browse.o[i];
			if (item.tagname == 'jwchat' && item.xmlns == 'jwchat:state') {
				if (typeof(item.presence) != 'undefined' && item.presence != 'undefined' && onlstat == 'login')
					onlstat = item.presence;
				
				if (typeof(jabber.browse.o[i].hiddenGroups) != 'undefined'  && jabber.browse.o[i].hiddenGroups != '') {
					var hiddenGroups = jabber.browse.o[i].hiddenGroups.split(",");
					for (var i in hiddenGroups)
						if (hiddenGroups[i] != '')
							roster.hiddenGroups[hiddenGroups[i]] = true;
					roster.print();
				}
			}
		}
	}

	if (onlstat == 'login')
		onlstat = 'available';
	// send presence
	changeStatus(onlstat);

	// get prefs
	fCBLoad("iq","?sid="+sid+"&ns=jabber:iq:private&get="+msgEscape("<jwchat xmlns='jwchat:prefs' />"),handlePrefs);
}

var disco = new Object();
var disco_info_count;
function handleDiscoItemResult(jabber) {

	fdebug(jabber,2);

	if (typeof(jabber.browse) == 'undefined' || typeof(jabber.browse.o) == 'undefined' || jabber.browse.o.length == 0) {
		fdebug("missing jabber.browse.o: " + jabber,1);
	} else {

  	var target;
    if (jabber.from != JABBERSERVER)
      fdebug("target not yet implemented",1)
	  else {
      target = disco;
		
    	target.items = new Array();
    	for (var i in jabber.browse.o) {
		    var item = new Object();
        item = jabber.browse.o[i];
		    target.items = target.items.concat(item);
      }
	    // now start querying items
      disco_info_count = 0;
      fCBLoad("iq","?sid="+sid+"&to="+target.items[disco_info_count].jid+"&ns=http://jabber.org/protocol/disco%23info",handleDiscoInfoResult);
      return;
    }
  }  
  poll();
}

function handleDiscoInfoResult(jabber) {

	fdebug(jabber,2);

	if (jabber.type == 'error' || typeof(jabber.browse) == 'undefined' || !jabber.browse.o)
		disco.items[disco_info_count].error = true;
	else {
		disco.items[disco_info_count].info = new Array();
		disco.items[disco_info_count].info = jabber.browse.o;

		// check if we've got a loghost
		var store_found = false;
		var xmlns_found = false;
		for (var i in disco.items[disco_info_count].info) {
			var item = disco.items[disco_info_count].info[i];
			if (item.tagname == 'identity' && item.category == 'store')
				store_found = true;
			if (item.tagname == 'feature' && item.far == 'http://jabber.org/protocol/archive')
				xmlns_found = true;
		}
		if (store_found && xmlns_found)
			loghost = jabber.from;

	}

	// query next item
	disco_info_count++;
	if (disco_info_count < disco.items.length)
		fCBLoad("iq","?sid="+sid+"&to="+disco.items[disco_info_count].jid+"&ns=http://jabber.org/protocol/disco%23info",handleDiscoInfoResult);
	else
	 poll(); // now start polling
}

/******************* HANDLER END *******************/


/******************* PROTO *******************/

function poll() {
  if (sid == 0 || status != 'polling')
    return;
  if (is.ie5 || is.op)
    frameLoad(frames["jwc_in"],"cache","?sid="+sid,"parent.handleEvent();");
  else
    frameLoad(frames["jwc_in"],"cache","?sid="+sid);
}

var groupchatsAt = 0;
var groupchats = new Array();
function handleSetGroupchatPresence(jabber,param) {
	if (groupchats.length > groupchatsAt) {
		fCBLoad("presence",param+"&to="+msgEscape(groupchats[groupchatsAt++]),handleSetGroupchatPresence,param);
	}
}

function sendPresence2Groupchats(gc,val,away) {
	groupchatsAt = 0;
	groupchats = gc;
	if (groupchats.length > 0) {
		var param = "?sid="+sid+"&show="+val;
		if (away && away != '')
			param += "&status="+msgEscape(away);
		fCBLoad("presence",param+"&to="+msgEscape(groupchats[groupchatsAt++]),handleSetGroupchatPresence,param);
	}
}

function changeStatus(val,away) {
  
  fdebug("changeStatus: "+val+","+away, 2);
  
  onlstat = val;
	if (away)
		onlmsg = away;
  if (sid == 0) { // login first
		status = 'sendPresence';
    fhdLoad("login-sid","?jid=" + msgEscape(jid) + "&pass=" + msgEscape(pass) + "&timeout=" + timeout);
    return;
  }

  var param = "?sid=" + sid;
  
  switch(val) {
  case "unavailable":
    val = "invisible";
    param += "&type="+val;
    break;
  case "offline":
    val = "unavailable";
    fhdLoad("logout-sid","?sid=" + sid);
    var img = eval(val+"Led");
    statusLed.src = img.src;
    if (away)
      statusMsg.value = away;
    else
      statusMsg.value = onlstatus[val];
    cleanUp();
    return;
    break;
  case "available":
    val = 'available'; // needed for led in status bar
    if (away) {
      param += "&status=" + msgEscape(away);
    }
		break;
  default:
    if (away) {
      param += "&status=" + msgEscape(away);
    }
    param += "&show="+val;
  }

  fhdLoad("presence",param);

  /* send presence to chatrooms
   */
  if (typeof(roster) != 'undefined') {
		sendPresence2Groupchats(roster.getGroupchats(),val,away);
  }

  var img = eval(val+"Led");
  if (sid != 0) {
    statusLed.src = img.src;
    if (away)
      statusMsg.value = away;
    else
      statusMsg.value = onlstatus[val];
  }
}


function init() {

  fdebug("init: jid="+jid+", pass="+pass,2);

  /* get frames */
  fhd = frames["jwc_out"].document;
  statusLed = frames["jwc_main"].document.getElementById('statusLed');
  statusMsg = frames["jwc_main"].document.getElementById('statusMsg');
  fmd = frames["jwc_main"].iRoster.document;

  /* login */
  if (is.ie5 && !is.mac) // still needed? check this again!
    frames["jwc_out"].document.body.attachEvent("onload",run);
  
  /* set title */
  document.title = "JWChat - " + nick;

  /* set nick */
  frames["jwc_main"].document.getElementById('myNickname').innerHTML = nick;  

  if (sid) {
    status = 'sendPresence';
    run();
  } else {
    changeStatus("login");
  }
}

function run() {
  
  fdebug("status:" + status,3);
	
  switch (status) {
  case 'sendPresence':
    
    var jabber = frames["jwc_out"].jabber;
    if (jabber && jabber.error) { // seems to be a not registered user
      if (confirm(loc("Couldn't log in!\nCreate new account?"))) {
        fhdLoad("pub/register","?jid="+jid+"&pass="+pass);
      } else {
        window.close();
      }
      break;
    }

    status = 'getRoster';
        
    fmd.getElementById('roster').innerHTML = "<div style=\"padding: 4px;\"><l>Loading Roster...<br>Please wait!</l></div>";
        
    if (!sid && (!jabber || !jabber.sid)) {
      changeStatus("available");
      return;
    }

    if (!sid)
      sid = jabber.sid;
    
    fdebug("got sid:\n" + sid,2);

    //changeStatus(onlstat);
		//break;
  case 'getRoster':
    status = 'printRoster';
    fhdLoad("roster","?sid="+sid);
    break;
  case 'printRoster':
    status = 'polling';
		fdebug("got roster: "+frames["jwc_out"].jabber.items,2);
    roster = new Roster(frames["jwc_out"].jabber.items,fmd);
		roster.usersHidden = usersHidden;
		roster.nick = jid.substring(0,jid.indexOf('@')); // remember nick for 1:1 Chats
    roster.print();
    
    playSound('connected');

		// get presence
		fCBLoad("iq","?sid="+sid+"&ns=jabber:iq:private&get="+msgEscape("<jwchat xmlns='jwchat:state' />"),handleSavedState);

    //poll();	// initial poll (not nice here)
    break;
  case 'polling':
    break;
  default:
    fdebug('unknown status: ' + status,1);
    break;
  }
}

function cleanUp() {
  sid = 0;
  status = '';

  /* close dependent windows */
  if (roster)
    roster.close();

  if (subw && !subw.closed)
    subw.close();

	if (typeof(ow) != 'undefined' && ow && !ow.closed)
		ow.close();

	if (searchW && !searchW.closed)
		searchW.close();

	if (ebW && !ebW.closed)
		ebW.close();

  fmd.getElementById('roster').innerHTML = '';

  // clear frames
  frames["jwc_sound"].document.open();
  frames["jwc_sound"].document.write();
  frames["jwc_sound"].document.close();
  frames["jwc_in"].document.open();
  frames["jwc_in"].document.write();
  frames["jwc_in"].document.close();
  frames["jwc_cb"].document.open();
  frames["jwc_cb"].document.write();
  frames["jwc_cb"].document.close();
  frames["jwc_out"].document.open();
  frames["jwc_out"].document.write();
  frames["jwc_out"].document.close();  
}

function logout() {
	// save presence
	var xml = "<jwchat xmlns='jwchat:state'><presence>"+onlstat+"</presence>";
	// save roster.hiddenGroups
	xml += "<hiddenGroups>";

	for (var i in roster.hiddenGroups)
		if (roster.hiddenGroups[i])
			xml += i+",";
	
	xml += "</hiddenGroups></jwchat>";

	fCBLoad("iq","?sid="+sid+"&ns=jabber:iq:private&set="+escape(xml));
	changeStatus("offline");
}

/* check for unsupported browsers */
if (is.b == 'op' || 
    is.b == 'Konqueror' || 
    navigator.userAgent.indexOf('Safari') != -1 ||
    (is.b == 'ns' && is.v < '5') ||
    (is.ie && is.mac) ||
    is.ie4
    ) 
  {
    open("unsupported.html","unsupported","width=380,height=180");
  }


/* quick hack - need this info before onload */
/* get args */
getArgs();
if (passedArgs['sid']) {
  sid = passedArgs['sid'];
} else {
  if (!passedArgs['pass']) {
    alert(loc("Password is missing.\nAborting..."));
    window.close();
    //    return false;
  }
  pass = passedArgs['pass'];
}
        
if (!passedArgs['jid']) {
  alert(loc("JID is missing.\nAborting..."));
  window.close();
  // return false;
}
jid = passedArgs['jid'];

if (!isValidJID(jid))
  window.close();


nick = jid.substring(0,jid.indexOf('@'));

/* get style */
if (passedArgs['style']) 
  stylesheet = THEMESDIR + "/" + passedArgs['style'] + "/" + stylesheet;

function updateStyleIE() {
  if (roster)
    roster.updateStyleIE();
}

onload = init;
onunload = logout;
onresize = updateStyleIE;

//-->
    </script>
  </head>
  <frameset rows="100%,0,0,0,0" border="0">
    <frame src="roster.html" name="jwc_main" marginwidth="0" marginheight="0" scrolling="no">
    <frame name="jwc_out" onload="run()" marginwidth="0" marginheight="0">
    <frame name="jwc_in" onload="handleEvent()" marginwidth="0" marginheight="0">
    <frame name="jwc_cb" onload="handleCB(frames['jwc_cb'].jabber)" marginwidth="0" marginheight="0">
    <frame name="jwc_sound" marginwidth="0" marginheight="0">
  </frameset>
  <body>
    <l>Your browser must support frames and javascript to use this application. Please refer to our <a href="help.html">online manual</a> for a list of supported browser.</l>
  </body>
</html>
